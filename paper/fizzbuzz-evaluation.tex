\subsubsection{Soft constraint specifications: Fizz-Buzz}
The Fizz-Buzz programming exercise is based on a children's game and frequently found in programming interviews. The synthetic dataset we generated obeys the following rules: for each record <x, y>, $x$ is a number between 0 and 1000, and $y$ is ``Fizz'' if \(x \mod 3 = 0\), ``Buzz'' if \(x \mod 5 = 0\), ``FizzBuzz'' if \(x \mod 15 == 0\), and \(x\) otherwise. However, we introduced three outliers to this data: \texttt{(25, "Fizz")}, \texttt{(28, "Woof!")}, \texttt{(30, "Buzz")}. Each demonstrates a different error, namely swapping \texttt{"Fizz"} and \texttt{"Buzz"}, producing entirely incorrect output, and failing to recognize that a number is divisible by both $3$ and $5$.

A traditional way of checking that all tuples verify the production rule outlined above is to encode this rule itself as a database integrity constraint. This requires encoding the full complexity of the exercise in the rule. If the exercise were to change, new cases must be added manually. Instead, a user might want to specify the bare minimum for the system to infer the rules; in this case, it is sufficient to add one extraction rule, mapping integers to two booleans denoting whether they are divisible by $3$ or $5$. Such a rule could be written like this:

\begin{minted}{python3}
@rule
def fizzbuzz(x: int) -> ("div 3", "div 5"):
  return (x % 3 == 0, x % 5 == 0)
\end{minted}

Running the discrete statistical analyzer on the synthetic datasets suggests that the two columns are correlated, and using the histogram model flags the aforementioned outliers. The output of the program for the \texttt{(30, "Buzz")} line, for example, is similar to:

\begin{lstnobreak}[gobble=2]
   $30$ $Buzz$
   > Values ($30$, $'Buzz'$) (0, 1) do not match
     features ($'div 3'$, $'erase numbers'$)
     • histogram for ('div 3', 'erase numbers'):
       █████ (False, 'Buzz')
       (False, 'Fizz')
       (False, 'Woof!')
       ██████████████████ (False, '<num>')
       $(True, 'Buzz')$
       ██████████ (True, 'Fizz')
       ██ (True, 'FizzBuzz')
\end{lstnobreak}

Using the partitioned histogram model produces similar output:

\begin{lstnobreak}[gobble=2]
   $30$ $Buzz$
   > Values ($30$, $'Buzz'$) (0, 1) do not match
     features ($'div 3'$, $'strp'$)
     • histogram for ('strp',) if 'div 3' = True:
       $('Buzz',)$
       ████████████████████ ('Fizz',)
       ████ ('FizzBuzz',)
     ... if 'div 3' = False:
       ████████████████████ ('<num>',)
       █████ ('Buzz',)
       ('Fizz',)
       ('Woof!',)
\end{lstnobreak}
